30.11 Perjantai
-------------

60 min: Tutustuttu harjoitustyön vaatimuksiin,
        rakennettu pohja aihemäärittelylle ja aloitettu tuntikirjanpito.
        
1.12 Lauantai
------------

3h: Asennettu tarvittavat ohjelmistot Git:n käyttöön ja tutustuttu GitHubiin.

15 min: Luokkakaavion eka versio valmis

60 min: Id-tyyppisen LExpression JUnit-testit laadittu, sekä koodia kirjoitettu
        sen verran, että ID-testit läpäisty. Application-tyyppisen LExpression
        JUnit-testit laadittu, sekä koodia kirjoitettu sen verran, että
        ID-testit läpäisty.

2.12 Sunnuntai
--------------

~1h: toString-metodien lisäys hoidettu, L-lauseiden arvon helppoa tulostusta
     varten REPL:in print()-metodissa. Lambda-tyyppisten lauseiden JUnit-testit
     ja koodi hoidettu: testit läpäisty.

~2h: Lisätty Pair-LExp, JUnit-testattu, aloitettu Parserin rakentaminen, ja
     ekat parser-testit läpäisty. Lisää LExp-testejä on tarkoitus tuottaa stten
     vaiheessa kun toimiva read()/parse on valmis ja tähänastiset lauseet on
     testattu 'in vivo'.

3.12 Maanantai
--------------

~1h: Luotu testiohjelma, joka testaa tällä hetkellä Parseria. REPL siis
     sisältää yksinkertaisen read()-vaiheen, ja Parser sisältää tällä hetkellä
     käyttäjän syötteet karkeasti LExp-muotoon parsaavan toiminnallisuuden.
     
4.12 Tiistai
------------

~30 min: ensimmäinen testiREPL valmis, Luotu uusi L-lausetyyppi - error.
         Luokkakaaviota ei tältä osin vielä päivitetty...
~10 min: refaktoroitu testiREPLIä.

7.12 Perjantai:
-------------

~40 min: reader() ja Parser ovat nyt selkeästi erotettu toisistaan, ja niillä
         on selkeästi omat tehtävät. Ainoa overlap näiden välillä on siinä,
         koska reader() tietää, että syötteen luku tulee lopettaa... Tätä
         varten readerin täytyy tehdä pikkuriikkisen parserointia itse. Muuten
         kaiken syötteiden parseroinnin hoitaa Parser-luokka.
         Muutama uusi ParserTesti toteutettu ja läpäisty.
         
~1h:     lisätty uusia "arvotyyppisiä" L-lauseita, rakennettu parseria. Parseri
		 on tosin vielä hyvin kaoottisesti organisoitu, mutta nyt se kuitenkin
		 osaa jo erotella joitakin käyttäjän syöttämiä L-lauseita ja niiden
		 perusteella luoda sopivia arvoja evaluoitavaksi.
		 Evaluaattori on vieläkin käytännössä olematon.
		 
		 
8.12 Lauantai:
--------------
~6h:     Reippaalla kädellä refaktoroitu Parseria, Muutettu muutamien
		 LExp-toimitaa.
         
9.12 Sunnuntai:
---------------
~5h:     Lisää refaktorointia ja Parserin rakennusta. Parseri jaettu useampaan
         pienempään osaan.
         Myös mm. Pair-tyyppien toString() metodi toimii tässä versiossa
         siten kuten listoja ja pareja tulisi Scheme-tulkilla näyttää.
         Luokkakaaviot menevät melko lailla uusiksi ensi viikon aikana,
         ja todennäköisesti myös parseria joutuu vielä melko lailla hiomaan.
         Se on vain tällä hetkellä täynnä kaikenlaista turhaa ja kömpelöä.
         Olisi pitänyt rakentaa heti aluksi tuo WordParser-koodi, koska se
         helpottaa huomattavasti LISP/Sheme-lauseiden manipuloimista...
         Parseri osaa tällä hetkellä parseroida atomilauseita, sekä
         lambda-lauseita.
         
11.12 Tiistai
-------------
~4h:	 Parserin viimeistely käynnistynyt, vaatii vielä testausta niin yksikkö-
		 testauksen, kuin integraatiotestauksenkin muodossa lisää. Bugeja parse-
		 rista karsittu pois. Käytännössä kuitenkin parserin toiminnallisuus
		 valmis. Ja nyt näyttää jo huomattavasti siistimmältäkin.
		 
12.12 Keskiviikko
-----------------
~1,5h:   Parserin viimeistely jatkuu... WordParser-luokan FirstWord näyttää
		 hieman ongelmatapaukselta. Ja ParserConstantsin ReservedFirstLetters
		 pitänee muuttaa ReservedLetters:ksi; eli siis, esim. sulkeita ei
		 sanan sisällä saa käyttää ollenkaan. Tämä on melko tärkeää ohjelman
		 myöhemmän toiminnan kannalta lauseiden evaluointivaiheessa...
 
 13.12 Torstai
 -------------
 ~3h:	 * Muutamia virheitä vielä ratkastu parserista, pari jäi jäljelle, mitä
		   pitää vielä hoitaa: Numeroille (kokonaisluvut ja liukuluvut) pitää
		   sallia myös negatiivisten arvojen parserointi. Ja Application täytyy
		   vielä testata silloin kun funktiona toimii monimutkaisempi lause
		   (lambda, tai toinen applikaatio).
		 * Nyt LExp-paketti sisältää kaikki L-lausetyypit.
		 * Parseriin pitää kirjoittaa vielä tuki Cond-lauseiden luomiselle.
		 * Testejä myös tehty muutama lisää.
		 * Koodia alettu kommentoimaan paremmin
		 * LExpin osalta luokkakaavio piirretty uusiksi; se pitää vielä
		   skannata.
 
 14.12 Perjantai
 ---------------
 ~4h:    * Parseria vielä vähän siistitty.
         * Environment luotu: käytännössä Environment on vain HashMap-Olio,
           joka varastoi tunnisteita ja niihin sidottja arvoja
           (yhdellä tunnisteella voi olla yksi arvo) ja kontrolloi arvojen
           hakua, etsintää sekä uusien arvojen lisäämistä.
         * Evaluaattorin luominen aloitettu.
         * Luokkakaaviota päivitetty myös ohjelman toiminnallisten osien
           kohdalta; jälleen täytyy skannata ne koneelle.
         * Kun evaluaattori on valmis, alkaa laajempi integraatiotestaus,
           ja kun kaikki on saatu toimimaan kunnolla, Parseri refaktoroidaan
           vielä kerran paremmaksi, niiltä osin mitä pystyy, ja dokumentoinnit
           laitetaan kuntoon, ja sitten jos vielä jää aikaa, mietitään, voiko/eh-
           tiikö ohjelmaan lisätä laajempia toiminnallisuuksia.
           (kuten set! proseduurin sekä tiedostosta ohjelmakoodin luvun).
           
15.12 Lauantai
--------------

~1,5h:	 * Evaluaattorin rakennus edistynyt hieman.

16.12 Sunnuntai
---------------

20 min:   * Aihemäärittely ja toiminnallisuus päivitetty
1h:		  * Nyt atomit toimivat järkevästi: ne eivät voi sisältää
			merkkejä, jotka voisivat sekoittaa parserin toimintaa
			(lähinnä sulkumerkit, tyhjä merkki, ja '\').
		  * Lisäksi jotain pientä hienosäätöä evaluaattorin rakenteeseen,
		    ennen kuin varsinainen "raskas työ" alkaa...
		    
17.12 Maanantai
---------------
~4h:	  * Siivottu vielä vähän parseria, ja rakenettu Evaluaattorin oikeasti
		    toimiva ensimmäinen versio: evaluaattori osaa nyt laskea
		    +, -, / ja * -laskuja puhtailla numeroilla sekä monimutkaisempia
		    +,-,*,/ -operaatioita sisältäviä +, -, *, / -laskuja.
           
18.12 Tiistai
-------------
~5h:	* uusi ongelmakohta havaittu (4 + 5)
	* Tyyppien tyyppimääritelmät muutettu Stringeistä Enumeiksi
	  (Eli; LExp sisältää nyt jäsenmuuttujan String type sijaan
		jäsenmuuttujan LExpTypes type, ja LExpTypes on
		ENUM).
	* Lisäksi tyyppimääritelmiä parannettu niin, että nyt kaikki
	  LIntit ja LDoublet ovat hierarkkisesti kantatyyppiä
          LValue, subTyyppiä LNumber, ja numerotyyppiä LInt/LDouble
	* Lisää primitiivifunktioita (nyt SkeletonLisp sisältää seuraavat
	  primitiivit: (+, -, /, *, <, <=, =, >=), jotka on määritelty
	  R4RS-standardin mukaisiksi
	  (TODO: Tarkista vielä, että näin oo, eikä huolimattomuudessa ole
		unohtunut esim. jonkun vertailuoperaattorin default-arvoja
		kun niitä kutsutaan ilman parametreja...)
		
19.12 Keskiviikko
-----------------
n. 20 min:	* Testit toimivat taas, Deadline II:hta varten: nyt pitäisi olla
			  kaikki Deadline II:n jutut kohdillaan... Paitsi se luokkakaavio,
			  jota en saanut millään skannattua ja päivitettyä nykyiselle
			  mallilleen...
			* TODO-listaa päivitetty
			
20.12 Torstai
-------------
~5h:		* Kone kaatui kriittisellä hetkellä ja n. 3 tunnint työ piti tehdä
		  uusiksi.
		* Exceptionien käsittely on nyt huomattavasti järkevämpää
		  (katso kuitenkin TODO)
		* Evaluaattori alkaa vihdoin toimia niinkuin sen pitäisikin,
		  (edelleenkin kuitenkin lambdat ja condit jää evaluoimatta)
		* primitiivejä lisää: abs ja ekat Special Form-primitiivit
		  (AND ja OR).
		* Definekin toimi jossain vaiheessa ennen koneen kaatumista,
		  mutta nyt se ei ole enää ollenkaan vaikea juttu, joten sen saanee
		  nopeasti hoidettua.

~1h:		* applyLambda on toiminnallisuudeltaan valmis; se kykenee mm.
		  evaluoimaan seuraavan lambda-lauseen:
		  ((lambda (x) ((lambda (y) (+ x y 3)) x)) 7)
		  oikeaan arvoon 17.
		* lambda-lauseiden muuttujien mahdollisuus olla joko
		  tavallisia parametrimuuttujia TAI listamuuttujia, tekee tosin
		  metodista hieman ärsyttävän näköisen... Tätä olisi syytä
		  joko refaktoroida, tai sitten poistaa listamuuttujaominaisuus
		  kokonaan.
		  listamuuttuja on siis lambda-lauseissa muotoa:
		  x: ((lambda x body) 'a 'b 'c)
		  joka voisi muuttaa seuraavaan kuvitteelliseen lambda+let-muotoon:
		  ((lambda (x y z)
		     (let ((x) (list x y z))
			body))
		   'a 'b 'c)

~5min:		* applyLambdassa() havaittu pieni bugi: kun kyseessä on listamuuttuja
		  niin eihän suinkaan parametreina annettuja arvoja etukäteen
		  evaluoida, vaan ne laitetaan uudeen list-applikaatioon sellaisenaan
		  ja list-applikaation evaluointivaiheessa ne vasta evaluoidaan.
		  tämä jo selkeytti metodia huomattavasti. Nyt homman pitäisi toimia
		  paljon paremmin!

~15min:		* primitiivi define lisätty: nyt esim lause:
		  ((lambda (x y) ((lambda (z) (define t (+ z x y))) (* x y))) 5 7)
		  evaluoidaan luvuksi 47 ((5*7) + 5 + 7) ja tämän jälkeen
		  globaaliin ympäristöön on ilmestynyt ID T=47'

~2h:		* Integraatiotestauksella löytyi melko vakava ja ongelmallinen virhe, jota
		  metsästettiin puolitoista tuntia. Virhe oli kaikessa lyhykäisyydessään seuraava
		  (Tässä suoraan tulkin syöte/tulosteparit:
		  >> (define t (lambda (x) (+ x 2)))	OK
		     <ANONYMOUS PROCEDURE>		OK
		  >> (t (+ 8 3))			OK
		     13					VIELÄKIN AIVAN FINE
		  >> (t '#t)				PITÄISI TUOTTAA VIRHE
		     ID UNBOUND: T			VIRHE ON AIVAN ROSKAA!!!

		  Tämä johtui siis siitä, että applyLambda ei itse käsitellyt niitä poikkeuksia
		  mitenkään, joita eval():in kutsu komennolla:
		  returnVal = eval(lambdaBody.get(i), newEnv);
		  tuotti, vaan heitti ne autuaan tietämättömänä eteenpäin, jolloin käy niin, että
		  se apply():n instannsi, joka alunperin yritti hakea T:tä senhetkisestä ympäristöstä,
		  ja joka T:n sieltä löysi, ja joka apply():asi taas eteenpäin evaluoiden ensin
		  T:n bindaaman arvon, lopulta yritti T:tä muuttaa primitiiviproseduuriksi siinä
		  vaiheessa kun se sai tiedon, että T:tä vastaavaa arvoa ei voitukaan evaluoida...
		  Ratkaisu:
		  Luo oma LambdaEvaluationException, jonka applyLambda heittää aina kun sille selviää,
		  että kyseistä lambda ei voidakaan evaluoida, ja laita sitten apply() vastaavasti
		  käsittelemään tämä tilanne. Nyt:
		  >> (define t (lambda (x) (+ x 2)))	OK
		     <ANONYMOUS PROCEDURE>		OK
		  >> (t (+ 8 3))			OK
		     13					VIELÄKIN AIVAN FINE
		  >> (t '#t)				PITÄISI TUOTTAA VIRHE
		     <ERROR>: PROCEDURE + EVALUATES ONLY TO NUMBERS

		  Ja virheilmoitus toimii niin kuin sen pitääkin!

21.12 Perjanta
--------------

~40min:		* Oletettavaa oli, että eilinen ongelma ilmeni myös silloin kun yritti tehdä jotain
			  seuraavankaltaista LValueilla:
			  >> (define t 0)
			  0
			  >> (t 9)
			  <ERROR>: UNBOUND ID T
			  
			  nyt ongelma on sen suhteen myös korjattu. Define tosin kaipaa vielä lisätestausta,
			  muidenkin L-lauseiden yhteydessä kuin vain Lambdojen ja LValueitten...
			  
			* EXIT primitiivin toiminnallisuus lisätty.
			
			* Pari uutta Exception-luokkaa lisätty.
			  (kts. TODO - kohta 6)
			  (LambdaEvaluationExceptionin nimi muutettu myös järkevämmäksi:
			   LambdaApplicationException - sillä kyseiset poikkeukset tapah-
			   tuvat nimenomaan Lambda lauseiden apply()-vaiheessa, eikä suinkaan
			   eval()-vaiheessa
			  (vrt.
			      eval((lambda (x) x)) 				=> <ANONYMOUS PROCEDURE>
			      eval(((lambda (x) x) 'IDENTITY)) 	=> IDENTITY
			   )
			   
~2h:		* Uusia primitiivejä: LIST ja PAIR.
			* Törmätty uuteen bugiin parserissa - Korjataan pikimmiten
			  (kts. bugeja 1)
			* Uusi Exception: ApplyPrimitiveException
			* apply()-rutiinia parannettu:
			  jos appllikaatio sisältää ensimmäisenä IDn -
			  vaikkapa (f 0) - sen tulkinta pitäisi tästä lähtien
			  toimia aina: eli poikkeus heitetään REPL:ille aina mikäli
			  f ei ole bindattu primitiiviin tai lambda-lauseeseen taikka
			  sellaiseen cond-lauseeseen, jonka tuloksena on joko
			  primitiiviproseduuri tai lambda-lause.
			* Tässä vaiheessa on jo pakko myöntää, että LExp-abstraktiluokan
			  String body-jäsenmuuttuja on aivan turha kaiken muun kuin
			  testauksen kannalta. Se on pakko repiä jo pois ja ohjelmaa
			  täytyy sopeuttaa tähän uuteen muutokseen.
			  Tämä tosin vaatii hieman tylsää työtä, mutta sen pyrin
			  tekemään ensi viikon alusta.
			  
			
 TODO
 ----
  Päivitä luokkakaavio Deadline II:ta varten!!! (se ei pakosti onnistu, sillä
	en ole varma pääsenkö toimivan skannerin luo ennen DeadLine II:hta).
  +,-,*,/ -laskuille: entä jos käyttäjä yrittää tehdä laskutoimituksen, jonka
					  tulos ei mahdu Javan int-tai double-tyyppiseen lukuun?
					  Jonkinlainen virheentarkistus oisi tällöin paikoillaan...
  Pitäisikö osa parseri rakentaa kokonaan uusiksi? Tätä voinee pohtia...
  
  19.12-23.12:
  1) Poista LExp-luokan body-jäsenmuuttuja ja muokkaa muu ohjelma sellaiseksi,
     että se toimii ilmankin...
  2) Korjaa merkkijonobugi, testaa ohjelman kaikkea tähänastista toimintaa
     merkkijonoilla, ja katso löytyykö uusia bugeja...
  3) Luo tuki Cond-lauseiden evaluoimiselle
  4) Lisää primitiivejä; tällä viikolla pitäisi saada kaikki primitiivien
     käsittelijät valmiiksi.
  5) mieti miten if...else if...else, osioita voisi siivota parempaan
     muotoon
  6) Voisiko Exceptioneiden käsittelyä vielä parantaa erottelemalla erillaisia
     poikkeustyyppejä? Sitä on syytä miettiä...
     (21.12: Päätös alkaa luoda omia Exceptioneitä, oli ihan järkevä, sillä nyt
      niiden avulla voidaan hallita järkevämmin poikkeuksellista toimintaa.
      Tässä vaiheessa tosin voisi miettiä, miten näitä voisi parhaalla tavalla
      hyödyntää: esim. voisiko parserille luoda omia ParserExceptioneitä, joiden
      avulla Read pystyisi lopulta palauttamaan kustomoidun virhetekstin, joka
      ei olisi riippuvainen siitä, mitä kaikissa eri parserointivaiheissa on
      tapahtunut...)
     
  7) voisiko applyLambdaa parannella jotenkin vieläkin selkeämmäksi?
 
 Ongelmakohtia
 -------------
 1. Parseri joutuu useaan otteeseen tekemään samaa työtä (esim. tarkistaa onko
 kyseessä sulkeiden sisällä oleva L-Lause. Nämä turhat tarkistukset ovat melko
 kömpelöitä.
 
 2. Tässä mallissa Evaluaattori joutuu vielä ainakin Lambda-lausekkeiden
    bodien osalta ja cond-bodien osalta parseroimaan uudestaan samaa lausetta:
    toki, näitä osia ei ole ennestään kovin kummoisesti parseroitu,
    mutta tehdäänkö tässä kuitenkin vähän niinkuin tuplasti työtä?
    
3. Evaluaattori on muuten varsin kiva, mutta sen ApplyPrimitive:stä taitaa
   tulla aivan turhan liian sotkuinen.

5. PrimitiveApplier täytyy testata kunnolla seuraavaksi
   (sitä ei ole vielä yksikkötestein testattu ollenkaan...)
   Muuten Evaluaattori on testattu vain integraatiotestauksella,
   (kuten myös REPL)
 
Parseri näyttäisi tosiaan siis olevan (kuten jo ennakkoon otaksuinkin) se
ehdottomasti haastavin osio.

Bugeja
------
1. Jos välimerkkejä sisältävän merkkijonon syöttää osana monimutkaisempaa L-lausetta,
   WordParser ei osaa erottaa merkkijonoa kokonaisuutena, vaan palauttaa sen yksittäisinä
   sanoina... Täten merkkijonojen käyttö monimutkaisemmissa lauseissa aiheuttavat
   tulostuksena täydellistä roskaa...
